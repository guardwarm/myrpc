# RPC框架

## 为什么要学习RPC

RPC（Remote Procedure Call） 远程过程调用

随着单机性能逐渐无法满足用户需求，微服务、分布式已逐渐成为大型项目的必然选择。用于解决分布式系统间通信问题的RPC框架也就显得尤为重要。

## 设计

### 功能需求

- 基础：网络通信
- 扩展：连接管理、健康检测、负载均衡、优雅宕停机、异常重试、业务分组、熔断限流

目前只实现了网络通信和负载均衡

### 作用 

- 屏蔽远程调用与过程调用的区别，使开发人员更加专注于业务流程
- 隐藏底层网络通信的复杂度

### 技术

**<u>序列化和反序列化</u>**

由于网络传输采用的是面向字节流的TCP连接，所以必然涉及序列化和反序列化操作

- JDK自带的Serializable和ObjectOutputStream

只支持Java、效率一般、存在安全性问题

序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。

- JSON

典型的key+value方式，可读性极高

额外空间消耗较大

无类型，一些弱类型语言支持还行，在Java这种强类型语言需基于反射统一处理，性能较差

传输数据量小时可以用，不然性能太差

- XML

  和JSON情形比较相似

- Hession

动态类型、二进制、紧凑、可跨语言移植

比JSON、JDK序列化更高效，生成的字节也更少

**缺点**：对Java里一些常见对象类型支持不够好

LinkedHashMap、LinkedHashSet等，可通过扩展Collection.Deserializer修复

Locale类，拓展Context.SerializerFactory类修复

Byte/Short 反序列化后变为Integer

- Protobuf

性能高、多语言，但使用略复杂

- Protostaff

Java版的Protobuf

- 总结

  序列化优先级：安全性>通用性>兼容性>性能、空间开销>可读性

  对象要尽量简单，无太多依赖，高内聚

  *入参对象与返回值不要太大*

  尽量使用原生类型，尤其是集合类

  不要有太复杂的继承关系尤其是父子类



<u>**网络IO模型**</u>

IO分为<u>等待数据</u>和<u>拷贝数据</u>两部分

- BIO

发起IO调用后就陷入阻塞，直到数据拷贝到用户数据后，恢复执行

- NIO

每个进程在等待数据阶段不会阻塞，但需要不断轮询查看数据是否准备好了，可以开始拷贝了

- IO多路复用

经典的Reactor模式，Redis、Java的NIO、Nginx都使用了这个

一个select线程管理多个socket（epoll是可以增加socket上限，默认最大为1024）

- 信号驱动IO

等待阶段不轮询，会有信号通知数据准备好了

- AIO

数据拷贝完才通知

<u>扩展：零拷贝</u>
应用程序\<\=\=\>  应用缓冲区 \<\=\=\> 内核缓冲区  \<\=\=\>  网卡   \<\=\=\>

常规零拷贝指的是优化掉应用缓冲区到内核缓冲区的拷贝

mmap+write   利用虚拟内存将两个缓冲区映射到一块

sendfile函数在两个文件描述符之间传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，被称为**零拷贝**

Netty的零拷贝为用户空间的，主要是偏向于数据操作的优化上

ByteBuf优化用户空间的拷贝问题，解决粘包拆包问题

也提供了基于sendfile的解决方案